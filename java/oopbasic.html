<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>JavaSE 笔记（三）面向对象基础篇</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="ccb81fbc-650c-4e4a-8b72-2d8bd5d45c6d" class="page sans"><header><h1 class="page-title">JavaSE 笔记（三）面向对象基础篇</h1><p class="page-description"></p></header><div class="page-body"><figure id="46a41134-fcbc-40e6-957d-a3394b92ea4c" class="image"><a href="https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png"><img src="https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png"/></a></figure><p id="75aecce7-a7f7-4060-9681-d4610721a37a" class="">image-20220918121719900</p><h1 id="f610cbb9-e63f-4233-810e-0d5f811cc865" class="">面向对象基础篇</h1><p id="485d4794-c30a-4c91-8f9c-5255c6b58956" class="">我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。</p><blockquote id="977fb500-75e4-43f1-834b-ebd7c40264b9" class="">面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。</blockquote><p id="439eda8f-cdd3-450a-8892-cb2e187c9d2a" class="">这一章开始难度就上来了，所以说请各位小伙伴一定认真。</p><h2 id="4fad2ca7-8d3f-42f0-9b87-8f432a8e541b" class="">类与对象</h2><p id="d9f8d620-e4fb-4920-8a13-1df484b87c99" class="">类的概念我们在生活中其实已经听说过很多了。</p><p id="abe21363-d108-425a-a78a-97bbfb1e9181" class="">人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p id="b93de179-1011-4cb3-967a-2ec72250c061" class="">对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。</p><figure id="9e0379b6-3f7a-4478-8861-d875947305a8" class="image"><a href="https://s2.loli.net/2022/09/19/U2P7qWOtRz5bhFY.png"><img src="https://s2.loli.net/2022/09/19/U2P7qWOtRz5bhFY.png"/></a></figure><p id="64075757-009b-4c74-a85e-6b8dd093b0d8" class="">image-20220919203119479</p><p id="e9507d05-cb06-4782-8b01-ac05b9d02efe" class="">所以说，类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul id="65378256-2479-4480-978c-8b4a9829c758" class="bulleted-list"><li style="list-style-type:disc">A：是谁拿走了我的手机？</li></ul><ul id="807a84bb-159f-49b8-87a0-f7e7966f2d3b" class="bulleted-list"><li style="list-style-type:disc">B：是个人。（某一个类）</li></ul><ul id="c126cf97-d61c-4490-a35e-74e8e0c6d69c" class="bulleted-list"><li style="list-style-type:disc">A：我还知道是个人呢，具体是谁呢？</li></ul><ul id="30c385f4-60d8-4b5b-aaea-623c8332a8b2" class="bulleted-list"><li style="list-style-type:disc">B：是XXX。（具体某个对象）</li></ul><p id="20b32c49-95dc-4a83-b0c9-879bc0acc560" class="">而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为<strong>面向对象编程</strong>。</p><h3 id="363177b1-01d5-43a5-8bd7-63cb42a205f1" class="">类的定义与对象创建</h3><p id="25e73958-aa93-4fca-9d53-693a09c01090" class="">前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p id="20f664c6-115e-4107-8cc2-7a076cd9ff86" class="">比如现在我们想要定义一个人类，我们可以右键<code>src</code>目录，点击创建新的类：</p><figure id="3049572b-81af-4928-a1eb-69f343d3ab61" class="image"><a href="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png"><img src="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png"/></a></figure><p id="685f5f17-0e1f-4160-8fb3-ab34a1ed3b13" class="">image-20220919204004526</p><p id="c008b66b-f0cf-440b-a5ca-6531d701b8a9" class="">我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><figure id="e5855bc8-fd3b-4448-a942-184e84ef3ece" class="image"><a href="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png"><img src="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png"/></a></figure><p id="3c8bba5a-c65e-4e86-a1b5-58c5d305e034" class="">image-20220919204159248</p><p id="1d08b6b0-aa34-46b5-b689-8eb1e954d220" class="">可以看到，现在我们的目录下有了两个<code>.java</code>源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。</p><p id="c705520f-adc9-4716-a97d-1ffc77b858d9" class="">我们来看看创建好之后，一个类写了哪些内容：</p><pre id="09b19eff-5ec6-4a14-9636-f5f976550b9b" class="code code-wrap"><code>public class Person {}</code></pre><p id="f919cc32-103f-45c9-a13e-effdcb1dcdea" class="">可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。</p><p id="1791b601-66c6-4638-9181-f3f7ceac8fbc" class="">现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？</p><p id="72e8efe4-0f15-47a3-a3fb-c719a990a145" class="">我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><pre id="26859c50-263b-4d7b-ba75-0f537b30ef41" class="code code-wrap"><code>public class Person {   //这里定义的人类具有三个属性，名字、年龄、性别    String name;   //直接在类中定义变量，表示类具有的属性    int age;    String sex;}</code></pre><p id="ad6a5df4-8fd7-4f05-bb57-a80cecb39dac" class="">可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。</p><p id="886a40d5-2b01-4607-8cd6-2d3fcb57d47d" class="">那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：</p><pre id="6dbfe170-ea9f-4e54-9b22-92a7caa59b83" class="code code-wrap"><code>new 类名();</code></pre><pre id="20dc73c4-2a49-425f-98ad-f9b2a5731c38" class="code code-wrap"><code>public static void main(String[] args) {    new Person();   //我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()    //这里创建出来的，就是一个具体的人了}</code></pre><p id="18605620-88b9-4aa8-8d94-3270601b8ea2" class="">实际上整个流程为：</p><figure id="0d2ae843-b628-4ef5-80ef-deba4431f091" class="image"><a href="https://s2.loli.net/2022/09/19/dSM4XDBV7qkIUlb.png"><img src="https://s2.loli.net/2022/09/19/dSM4XDBV7qkIUlb.png"/></a></figure><p id="9ac71114-9f43-4c9a-ad72-a7091a00a645" class="">image-20220919205550104</p><p id="14627e31-519c-4db8-8b09-1d3641547ad7" class="">只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。</p><h3 id="19105df3-ec31-4fd2-be03-2d684634ea80" class="">对象的使用</h3><p id="a29b24b6-0b59-4635-84ca-9f36a8ea34d7" class="">既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。</p><p id="7792a0c2-96bc-440b-b5b0-1b937dfa9450" class="">我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><pre id="c3aecafa-3626-4427-b63e-70b195187b75" class="code code-wrap"><code>public static void main(String[] args) {    //这里的a存放的是具体的某个值    int a = 10;    //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名    //这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象    Person p = new Person();}</code></pre><p id="62868775-dc4b-482c-bee4-d27b4a3104ba" class="">至于为什么对象类型的变量存放的是对象的引用，比如：</p><pre id="0e00cad1-23d8-4027-817a-08dd9a2ca7fb" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Person();    Person p2 = p1;}</code></pre><p id="4e0de75d-f729-4274-8662-fe2a0288c69c" class="">这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><figure id="b698defa-9fb5-4476-9ea7-0f18dced4fe5" class="image"><a href="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png"><img src="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png"/></a></figure><p id="d6925730-6363-454d-a61e-4e8a84e524dd" class="">image-20220919211443657</p><p id="cf77ea59-e92c-4459-88e8-57741973727d" class="">我们可以来测试一下：</p><pre id="6fa01fb6-2d00-485f-ab7a-6018e96afedd" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Person();    Person p2 = p1;    System.out.println(p1 == p2);    //使用 == 可以判断两个变量引用的是不是同一个对象}</code></pre><p id="eeeb5338-af1c-474f-a9ec-81b16c236f66" class="">但是如果我们像这样去编写：</p><pre id="8e7b2c40-63b6-4c54-8ad0-d985ebe76f1d" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Person();   //这两个变量分别引用的是不同的两个对象    Person p2 = new Person();    System.out.println(p1 == p2);   //如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了}</code></pre><p id="52a8b9ed-6822-4bdc-aff4-c99ce30f8da3" class="">实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。</p><p id="15c867e6-6167-4825-b36f-738f55004809" class="">现在我们有了对象的引用之后，我们就可以进行操作了：</p><figure id="698ff1d6-4e60-45e4-8af4-370243b80a02" class="image"><a href="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png"><img src="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png"/></a></figure><p id="b9d88424-c790-446b-b5ae-ef3708cb11a6" class="">image-20220919210058797</p><p id="2554e521-1ef1-49fd-8fc2-c110ac221be2" class="">我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p id="b66cec6e-b790-4f3b-9ef9-28d2f5fe7474" class="">比如我们可以修改对象的名字：</p><pre id="daf16404-b302-4bff-86c1-c4145795285b" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    p.name = &quot;小明&quot;;   //要访问对象的属性，我们需要使用 . 运算符    System.out.println(p.name);   //直接打印对象的名字，就是我们刚刚修改好的结果了}</code></pre><p id="0ec0150e-a8d6-47ef-ba51-2f65c1cf5a9e" class="">注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><pre id="4c258fd1-2e0c-42d1-9364-caaf8364b92a" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Person();    Person p2 = new Person();    p1.name = &quot;小明&quot;;   //这个修改的是第一个对象的属性    p2.name = &quot;大明&quot;;   //这里修改的是第二个对象的属性    System.out.println(p1.name);  //这里我们获取的是第一个对象的属性}</code></pre><p id="870671b0-db96-48b4-ae1e-992284f18900" class="">关于对象类型的变量，我们也可以不对任何对象进行引用：</p><pre id="539517ed-066f-4be4-be58-7b9ab9f84fba" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = null;  //null是一个特殊的值，它表示空，也就是不引用任何的对象}</code></pre><p id="d837009b-afc8-48e4-8ea8-34be9bc5f901" class="">注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）</p><p id="e402d116-312d-4396-8e1c-4ef569b9ec63" class="">虽然这样可以编译通过，但是在运行时会出现问题：</p><pre id="026776ed-9236-496f-b7c7-4a8d10761f99" class="code code-wrap"><code>public static void main(String[] args) {    Person p = null;   //此时变量没有引用任何对象    p.name = &quot;小红&quot;;   //我任性，就是要操作    System.out.println(p.name);}</code></pre><p id="dcdcf3df-869c-4100-952c-3b41f62fcade" class="">我们来尝试运行一下这段代码：</p><figure id="0535792d-3cbe-4c21-856f-02e5a177323d" class="image"><a href="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png"><img src="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png"/></a></figure><p id="a042d260-ad59-47b7-af8e-5a9349f663cb" class="">image-20220919213732810</p><p id="365be38f-3183-46ab-aab5-53985c7f5454" class="">此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。</p><p id="133eb7c0-6152-44da-81e0-3dd65e479c5b" class="">这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。</p><p id="70dd54d8-4b19-4a05-8cf5-04b410ae1a9c" class="">我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><pre id="181ecaa7-1cb4-4832-8ebe-802e972021de" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    System.out.println(&quot;name = &quot;+p.name);    System.out.println(&quot;age = &quot;+p.age);    System.out.println(&quot;sex = &quot;+p.sex);}</code></pre><p id="a2cd219d-f715-4aa4-9c0a-d8e67f39aaee" class="">我们来看看运行结果：</p><figure id="a9cb30b5-9445-4bef-8f76-b3332d1f1028" class="image"><a href="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png"><img src="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png"/></a></figure><p id="e9c05a26-788a-4aba-b357-d30f1350bd3e" class="">image-20220919214248053</p><p id="33fae9e1-cd8c-41ce-a3d5-a04a696d11cc" class="">我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="2eb96337-965c-4e18-acdd-244763f18fee" class="">方法创建与使用</h3><p id="363d989d-a23f-4e16-9a79-b2777d989c58" class="">前面我们介绍了类的定义以及对象的创建和使用。</p><p id="b35fcfd1-d91c-4365-8133-2b6b83868d27" class="">现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p id="8dae0904-1488-4448-b70b-06110711b679" class="">而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）</p><p id="322c79c5-f1a7-4072-8e4c-c58772772b36" class="">方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><p id="8707ceeb-eee8-422f-9534-c94a722a30ea" class="">方法的定义如下：</p><pre id="b6b107ee-1388-4bad-b52d-b8ff508a8c4e" class="code code-wrap"><code>返回值类型 方法名称() {
        方法体...
}</code></pre><p id="a2d0341c-6f53-4312-b623-7c281c4da958" class="">首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：</p><pre id="fc3c9419-ef06-4cf8-9b2e-43d1c2535ee7" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    //自我介绍只需要完成就行，没有返回值，所以说使用void    void hello(){        //完成自我介绍需要执行的所有代码就在这个花括号中编写        //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数）        //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值        System.out.println(&quot;我叫 &quot;+name+&quot; 今年 &quot;+age+&quot; 岁了！&quot;);    }}</code></pre><p id="fbe594d4-1956-4776-b7de-6534d4bed067" class="">注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p><figure id="de554f72-63b0-48b3-8a3d-899ea4e264c8" class="image"><a href="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png"><img src="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png"/></a></figure><p id="933e6e69-ed93-4669-b22f-83878e3fd66c" class="">image-20220920101033325</p><p id="87fc43aa-8878-4087-ad9e-97e629d9b545" class="">现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？</p><pre id="c5be84c1-5ba7-474a-a67e-14a1f043ec0d" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    p.name = &quot;小明&quot;;    p.age = 18;    p.hello();    //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可}</code></pre><p id="6a15e7b0-7162-4e87-a5d6-713608cef86f" class="">像这样执行定义好的方法，我们一般称为<strong>方法的调用</strong>，我们来看看效果：</p><figure id="8eaa89a7-d4e1-4f5b-a9a1-36a94dcef910" class="image"><a href="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png"><img src="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png"/></a></figure><p id="35e8869e-16d1-48c2-baf6-dcae710c116c" class="">image-20220919220837991</p><p id="92f97b5e-86cd-46b8-a4eb-88f54072d8d5" class="">比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：</p><pre id="7c07d153-f245-4216-b68d-d5de79d7e49e" class="code code-wrap"><code>//我们的方法需要别人提供参与运算的值才可以//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开int sum(int a, int b){   //这里需要两个int类型的参数进行计算}</code></pre><p id="232f4142-1797-4ad4-92ab-6755186cc1ca" class="">那么现在参数从外部传入之后，我们怎么使用呢？</p><pre id="00eecf2e-0407-4ad6-b402-fa0a4c4f212d" class="code code-wrap"><code>int sum(int a, int b){   //这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用    int c = a + b;   //直接c = a + b}</code></pre><p id="ca5f876a-085d-4d1b-822d-cc24769f4c8f" class="">那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><pre id="e4bfb186-382a-4088-9310-4e632d0acae8" class="code code-wrap"><code>int sum(int a, int b){    int c = a + b;    return c;   //return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了    //带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！}</code></pre><p id="3e61c803-5313-45ff-abaa-d168805615a1" class="">我们来测试一下吧：</p><pre id="4dbe64bc-6d16-4887-83db-bf8fcd770b55" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    p.name = &quot;小明&quot;;    p.age = 18;    int result = p.sum(10, 20);    //现在我们要让这个对象帮我们计算10 + 20的结果    System.out.println(result);    //成功得到30，实际上这里的println也是在调用方法进行打印操作}</code></pre><p id="43bd03cd-9acd-435a-8348-92917fa3e390" class=""><strong>注意：</strong>方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。</p><p id="81ef630d-c0c0-49e1-b3f4-bff6ee93b38e" class="">是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。</p><p id="32b04647-164b-4352-b1ce-d242cf36ad0f" class="">关于<code>return</code>关键字，我们还需要进行进一步的介绍。</p><p id="36e4e46d-0a79-4208-ab0b-331f45c5200d" class="">在我们使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><figure id="db2a70cb-191b-47c4-afab-cf7089c816fe" class="image"><a href="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png"><img src="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png"/></a></figure><p id="48ab328c-dc03-4045-8169-48523df2554f" class="">image-20220919222813469</p><p id="9eb5e2cf-b38e-440a-8d19-f344d180c9b8" class="">在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p id="ac72fb1a-0ada-4fdc-b383-b2b75d1f63ca" class="">如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><figure id="aa646172-1d63-4245-a2ea-17f32340dc5d" class="image"><a href="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png"><img src="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png"/></a></figure><p id="deeb69a0-e62d-434a-b4a7-6672157cb085" class="">image-20220919223037197</p><p id="0c3782e7-fd6f-454b-806c-c4490d230ee3" class="">只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p id="4142c3a6-4981-41a8-a663-2e7b4a84f155" class="">当然，如果方法没有返回值，我们也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><pre id="0c65c6b6-e299-4f9f-8d35-4b4ce186b9f1" class="code code-wrap"><code>void test(int a){    if(a == 10) return;    //当a等于10时直接结束方法，后面无论有没有代码都不会执行了    System.out.println(&quot;Hello World!&quot;);   //不是的情况就正常执行}</code></pre><p id="bdf5a0d0-5f2e-4c38-b4ce-eb67cf614891" class="">最后我们来讨论一下参数的传递问题：</p><pre id="aa4a61a9-fcd8-4ed4-92d8-3e520dcc822e" class="code code-wrap"><code>void test(int a){   //我们可以设置参数来让外部的数据传入到函数内部    System.out.println(a);}</code></pre><p id="9473501d-0611-48f5-bdb2-0bb026b0c83c" class="">实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：</p><pre id="e5b32295-91ef-42e3-90f8-11ad106183fd" class="code code-wrap"><code>void swap(int a, int b){   //这个函数的目的很明显，就是为了交换a和b的值    int tmp = a;    a = b;    b = a;}</code></pre><p id="c477b5f1-6c3a-4d86-a18d-611e6c0fe812" class="">那么我们来测试一下：</p><pre id="bf5bc024-6271-4882-8b02-b65b628222af" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    int a = 5, b = 9;   //外面也叫a和b    p.swap(a, b);    System.out.println(&quot;a = &quot;+a+&quot;, b = &quot;+b);   //最后的结果会变成什么样子呢？}</code></pre><p id="3b6b8a08-c148-4737-a5eb-fb65d8eed880" class="">我们来看看结果是什么：</p><figure id="25c8e071-2fa2-47ca-a7a4-690edb8f36ac" class="image"><a href="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png"><img src="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png"/></a></figure><p id="3201f14a-ea2b-48b3-8c33-79aee1105357" class="">image-20220919224219071</p><p id="dc753afa-b062-448d-a7b4-914944e4a6a3" class="">我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）</p><figure id="71120628-78cf-4c98-8b22-467f933be9d7" class="image"><a href="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png"><img src="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png"/></a></figure><p id="41380e5a-4bbf-495b-a50c-d1303c9ee32f" class="">image-20220919224623727</p><p id="dfedc231-e3b0-4bb6-8e37-355e3dea713e" class="">所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。</p><p id="83484657-fa81-4a93-a543-01c40113d6b7" class="">那么各位小伙伴看看下面的例子：</p><pre id="190e18b9-a1ca-4dc1-abbc-c39f53eadb4f" class="code code-wrap"><code>void modify(Person person){    person.name = &quot;lbwnb&quot;;   //修改对象的名称}</code></pre><pre id="2ca5e21c-88c1-4415-a2b3-2832286feb5a" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    p.name = &quot;小明&quot;;     //先在外面修改一次    p.modify(p);        //调用方法再修改一次    System.out.println(p.name);    //请问最后name会是什么？}</code></pre><p id="4a0a345a-22ad-4ba9-a7f6-453166a715b5" class="">我们来看看结果：</p><figure id="c98d0556-9239-4699-a6af-002e664b60b1" class="image"><a href="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png"><img src="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png"/></a></figure><p id="98997f5a-95b2-4ff3-91b0-a7d26a8ac42a" class="">image-20220919224957971</p><p id="2e7d919c-f596-43bc-b1dc-7b17a12d57b4" class="">不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？</p><p id="73c392fe-9e0c-4402-934e-971d0c88a0d8" class="">确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><figure id="9add0a06-de68-4af2-bcc4-693fd7bb5a04" class="image"><a href="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png"><img src="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png"/></a></figure><p id="3b800b0a-0541-45e7-a331-7e9787111676" class="">image-20220919225455752</p><h3 id="fce746c5-df80-474d-9732-b06e1a84aec5" class="">方法进阶使用</h3><p id="384bda2c-ed72-4ac0-8402-ea1ed2094980" class="">有时候我们的方法中可能会出现一些与成员变量重名的变量：</p><pre id="c58299dc-0897-4263-b43a-304e89bd51fd" class="code code-wrap"><code>//我们希望使用这个方法，来为当前对象设定名字void setName(String name) {}</code></pre><p id="f9619a96-c8a0-4f41-abc2-4476c1674b62" class="">此时类中定义的变量名称也是<code>name</code>，那么我们是否可以这样编写呢：</p><pre id="3160df40-7b3b-4530-a9e1-ba0d27c09865" class="code code-wrap"><code>void setName(String name) {    name = name;    //出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身}</code></pre><p id="6f13ba36-205d-4344-b97f-9034a3acd285" class="">我们来测试一下：</p><pre id="9e9f150b-558b-4c21-b9bf-ad8addbf76db" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    p.setName(&quot;小明&quot;);    System.out.println(p.name);}</code></pre><p id="cd748f40-a7f7-49d0-af68-8f93ff870056" class="">我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p><pre id="7a2acf88-c0cc-4778-b20e-ca73ba92221c" class="code code-wrap"><code>Person p = new Person();p.name = &quot;小明&quot;;    //我们之前在外面使用时，可以直接通过对象.属性的形式访问到</code></pre><p id="daf5acf1-c380-489b-aae7-ea89847484a1" class="">同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><pre id="8e2414b7-db8e-430b-9356-33550bce3467" class="code code-wrap"><code>void setName(String name) {    this.name = name;   //让当前对象的name变量值等于参数传入的值}</code></pre><p id="b645ec0e-ad77-4b9a-a4d8-6d1f38653384" class="">这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><pre id="86cde997-7fe8-4dd5-adca-d8fa7ca530f1" class="code code-wrap"><code>String getName() {    return name;    //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了}</code></pre><p id="d96a8619-db0b-4695-9509-c39dda6323e8" class="">我们接着来看方法的重载。</p><p id="80e401fa-5a4b-4ac3-a325-cf63686042f1" class="">有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p><pre id="82801afe-c2da-45ed-9caa-a6a5325d07e3" class="code code-wrap"><code>int sum(int a, int b){    return a + b;}</code></pre><pre id="73e271fd-b2b8-4055-968f-c4fb40fbbfcc" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    System.out.println(p.sum(10, 20));    //这里可以正常计算两个整数的和}</code></pre><p id="bf8a9f9e-eec8-4005-a6f9-e11050a688e6" class="">但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p><figure id="ead5d885-ac9b-44e5-bbb3-de681a3e57f5" class="image"><a href="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png"><img src="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png"/></a></figure><p id="b55580b8-b7de-4f16-9fdb-38b6b9ae1a8a" class="">image-20220920102347110</p><p id="cf5cdb75-2eca-40b3-9164-3b2d1040a520" class="">当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p><p id="2f4e48f3-7596-4b00-872c-efd7fc3b83dc" class="">一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><pre id="2ab0df6c-af27-428e-a32c-0d8591d5c9b2" class="code code-wrap"><code>int sum(int a, int b){    return a + b;}double sum(double a, double b){    //为了支持小数加法，我们可以进行一次重载    return a + b;}</code></pre><p id="01e7d11a-b423-41be-b49d-a0ca7db6a024" class="">这样就可以正常使用了：</p><pre id="b03deab2-d573-4c86-a11f-1e8adabe8b78" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();    //当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用    System.out.println(p.sum(1.5, 2.2));}</code></pre><p id="d203ec40-c516-4ca9-9f5e-cda5c7d02acc" class="">包括我们之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p id="16823577-e397-48d7-bf40-36c5409acd7e" class="">注意，如果仅仅是返回值的不同，是不支持重载的：</p><figure id="a76dd62d-6221-4e48-b905-108a8af94a0b" class="image"><a href="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png"><img src="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png"/></a></figure><p id="adc0d77c-e41a-4a6f-a971-b9b5492f3e57" class="">image-20220920102933047</p><p id="a110c1a1-c617-441f-a8fb-ee331b5be787" class="">当然，方法之间是可以相互调用的：</p><pre id="06ad2938-84f8-4c5b-b175-a128244391d1" class="code code-wrap"><code>void test(){    System.out.println(&quot;我是test&quot;);   //实际上这里也是调用另一个方法}void say(){    test();   //在一个方法内调用另一个方法}</code></pre><p id="d85b249a-6616-47a7-b049-829e2053f9eb" class="">如果我们这样写的话：</p><pre id="793adcf8-e4a5-4e01-9663-db17331a5b63" class="code code-wrap"><code>void test(){    say();}void say(){    test();}</code></pre><p id="0c306f45-e960-434b-bdd7-082962fcdf32" class="">各位猜猜看会出现什么情况？</p><figure id="8cf4b1da-660d-458d-a453-489d9eb314d1" class="image"><a href="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png"><img src="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png"/></a></figure><p id="ae0b4a58-2fe3-446f-b465-a9aa085e5786" class="">image-20220921001914601</p><p id="5abfec3c-a546-4d82-95e0-478f836be9f4" class="">此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p><p id="dc9478a4-37f8-4501-b151-4ab6d5585a7f" class="">方法自己也可以调用自己：</p><pre id="7e83655a-76fa-4380-9cb1-6904c0912aaf" class="code code-wrap"><code>void test(){    test();}</code></pre><p id="d28b3685-5a6e-4cd2-a954-c0f3fed5650d" class="">像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p><pre id="b45bf3b3-a2f7-4d1c-ba0c-a4a6f26a5c9e" class="code code-wrap"><code>int test(int n){    if(n == 0) return 0;    return test(n - 1) + n;    //返回的结果是下一层返回的结果+当前这一层的n}</code></pre><p id="355fc0ca-2b87-4358-b832-119e530dced8" class="">是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p><h3 id="59dca3dc-2148-45f0-8b02-a13f24d0deb9" class="">构造方法</h3><p id="60744f5f-8724-4185-a317-4edc128fc783" class="">我们接着来看一种比较特殊的方法，构造方法。</p><p id="fb8e94cf-f544-48af-aa9d-2463611b9e1d" class="">我们前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p><p id="668ddcf4-8eb3-4621-8c89-59df47e2f7c1" class="">实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p><pre id="6cb7722f-09b4-4091-9258-f369ed926a98" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    public Person() {    //反编译中，多出来了这样一个方法，这其实就是构造方法    }}</code></pre><p id="e3fa168d-26d8-4381-a459-b294d7264a1d" class="">构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p><pre id="2e8928bb-cd9e-48c1-a653-66973ccfff10" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    Person(){    //构造方法不需要指定返回值，并且方法名称与类名相同        name = &quot;小明&quot;;   //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理        age = 18;        sex = &quot;男&quot;;    }}</code></pre><p id="35da6dcc-e29b-48a3-bf01-3106b94dd421" class="">构造方法会在new的时候自动执行：</p><pre id="eaf88d11-bafc-4e97-abb9-dd20568d5112" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person();   //这里的new Person()其实就是在调用无参构造方法    System.out.println(p.name);}</code></pre><p id="dad46f5c-95e3-40fc-a3ec-8b35186bd1b4" class="">当然，我们也可以为构造方法设定参数：</p><pre id="fbe3f729-30d3-4c4e-8cdd-691a52ddb25a" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    Person(String name, int age, String sex){   //跟普通方法是一样的        this.name = name;        this.age = age;        this.sex = sex;    }}</code></pre><p id="425438c7-c38c-484f-89ec-c1e57d59f8d7" class="">注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p><pre id="0386a304-23c4-494e-a879-86c305f54b24" class="code code-wrap"><code>public static void main(String[] args) {    Person p = new Person(&quot;小明&quot;, 18, &quot;男&quot;);   //调用自己定义的带三个参数的构造方法    System.out.println(p.name);}</code></pre><p id="dd2e83a5-dce3-4aac-998f-9acd08ecd1a5" class="">我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p><p id="98922ef1-8c2a-4f8e-9540-3b8202a54c8d" class="">当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p><pre id="07e01d0d-f0f6-4a9c-97eb-b707a4d34a3e" class="code code-wrap"><code>public class Person {    String name = &quot;未知&quot;;   //直接赋值，那么对象构造好之后，属性默认就是这个值    int age = 10;    String sex = &quot;男&quot;;}</code></pre><p id="8223f54e-bba6-499f-85df-ac550d9354fd" class="">这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><pre id="0cf5273b-e4ae-4a11-802b-197aa4ec6156" class="code code-wrap"><code>Person(String name, int age, String sex){    System.out.println(age);    //在赋值之前看看是否有初始值    this.name = name;    this.age = age;    this.sex = sex;}</code></pre><p id="7a6fcabc-e90a-4692-818f-0870657cba7c" class="">我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><pre id="c4ab1eae-27c1-4721-8127-604a5230e8a1" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    {        System.out.println(&quot;我是代码块&quot;);   //代码块中的内容会在对象创建时仅执行一次    }    Person(String name, int age, String sex){        System.out.println(&quot;我被构造了&quot;);        this.name = name;        this.age = age;        this.sex = sex;    }}</code></pre><p id="3ec11a08-6673-4609-a2f0-8b4a8f419c60" class="">只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="cd4ce3d3-f375-41b4-9c53-4476bd75f430" class="">静态变量和静态方法</h3><p id="5c222507-98b5-4099-b2cb-a1567caca535" class="">前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。</p><p id="7e6f03b1-ec76-4277-b19b-7d362432f7bc" class="">静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><pre id="910347ef-ef85-43ce-ae8d-557dfd3cb99c" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    static String info;    //这里我们定义一个info静态变量}</code></pre><p id="885478f5-152c-4267-8357-73f38bfd5dcf" class="">我们来测试一下：</p><pre id="278f2c3d-27e4-4cb1-b6aa-2e9e5ca04728" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Person();    Person p2 = new Person();    p1.info = &quot;杰哥你干嘛&quot;;    System.out.println(p2.info);   //可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标}</code></pre><p id="e5d79c9b-4679-4268-9cb5-ac6446e4a757" class="">所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><pre id="e03b6621-123e-40d3-91a2-5d39b8dda223" class="code code-wrap"><code>public static void main(String[] args) {    Person.info = &quot;让我看看&quot;;    System.out.println(Person.info);}</code></pre><p id="0d6b6c41-db41-4875-aafd-36c706993b08" class="">同样的，我们可以将方法标记为静态：</p><pre id="83ec3778-e037-4306-929e-63688024a475" class="code code-wrap"><code>static void test(){    System.out.println(&quot;我是静态方法&quot;);}</code></pre><p id="5d35bed0-c1d5-4ba7-b382-a1ae2c5e5fd6" class="">静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><figure id="f7c2cffa-c964-40b4-beb4-589389ee900b" class="image"><a href="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png"><img src="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png"/></a></figure><p id="50e807ed-5aca-4896-8b4d-b95546c74ecf" class="">image-20220920234401275</p><p id="98d6dcd2-0c39-42be-8a54-32051653d2d5" class="">因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：</p><figure id="49a15fb5-3e44-41d1-9f0b-5d520fb7437e" class="image"><a href="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png"><img src="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png"/></a></figure><p id="19803208-d128-47fc-9865-c011a156ef8c" class="">image-20220920235418115</p><p id="e3422cd1-f4eb-4402-8079-f4a893c987f5" class="">成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p id="c6783148-02ed-408e-a303-bb0b4619a8ce" class="">但是静态方法是可以访问到静态变量的：</p><pre id="fc0cbd83-f9d0-46d5-b64f-ae4309fdbf68" class="code code-wrap"><code>static String info;static void test(){    System.out.println(&quot;静态变量的值为：&quot;+info);}</code></pre><p id="84e415d8-08d3-4eae-bcb0-268c1d8e1f3a" class="">因为他们都属于类，所以说肯定是可以访问到的。</p><p id="170ac6c5-bb79-4e2a-99e6-dd02ecef930b" class="">我们也可以将代码块变成静态的：</p><pre id="e8a0f686-264d-4ca9-8591-dc904e85cfca" class="code code-wrap"><code>static String info;static {   //静态代码块可以用于初始化静态变量    info = &quot;测试&quot;;}</code></pre><p id="f636b49c-fbd2-475a-96b5-f82205ef6172" class="">那么，静态变量，是在什么时候进行初始化的呢？</p><p id="1364f8e1-65fd-4ed4-8349-b07fadc06bdc" class="">我们在一开始介绍了，我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul id="a22bcf8e-1793-498b-a506-5bcd8217355e" class="bulleted-list"><li style="list-style-type:disc">访问类的静态变量，或者为静态变量赋值</li></ul><ul id="805e35bf-a58b-45b5-a726-218d779bc0da" class="bulleted-list"><li style="list-style-type:disc">new 创建类的实例（隐式加载）</li></ul><ul id="532562d7-1871-4751-9fda-d3bc59a4ebfd" class="bulleted-list"><li style="list-style-type:disc">调用类的静态方法</li></ul><ul id="6211cb12-d684-496b-ab87-01692b3b8c4d" class="bulleted-list"><li style="list-style-type:disc">子类初始化时</li></ul><ul id="34b86e16-5ae3-451e-9a33-4580959dfb34" class="bulleted-list"><li style="list-style-type:disc">其他的情况会在讲到反射时介绍</li></ul><p id="4e52613a-cc8b-4c19-8a5f-0ba3bc60a830" class="">所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p id="1b36287e-82be-400a-b6f0-b7ab8e1d025e" class="">我们可以来测试一下：</p><pre id="e2208e50-a3d8-4f91-a72d-4662f409a18c" class="code code-wrap"><code>public class Person {    String name = test();  //这里我们用test方法的返回值作为变量的初始值，便于观察    int age;    String sex;    {        System.out.println(&quot;我是普通代码块&quot;);    }    Person(){        System.out.println(&quot;我是构造方法&quot;);    }    String test(){        System.out.println(&quot;我是成员变量初始化&quot;);        return &quot;小明&quot;;    }    static String info = init();   //这里我们用init静态方法的返回值作为变量的初始值，便于观察    static {        System.out.println(&quot;我是静态代码块&quot;);    }    static String init(){        System.out.println(&quot;我是静态变量初始化&quot;);        return &quot;test&quot;;    }}</code></pre><p id="a7e9244d-8713-452b-bc6d-1c9a39664faa" class="">现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：</p><figure id="6de2796a-fa0e-4a16-b4db-778e0d1b1eac" class="image"><a href="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png"><img src="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png"/></a></figure><p id="27835280-a9a7-4869-bab4-047aae9b2dcd" class="">image-20220921000953525</p><p id="70a6555c-bba3-4e94-9c29-48cd4c891d96" class="">可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p id="827632b0-52d7-406e-a197-bcb27bb687fa" class="">当然，如果我们直接访问类的静态变量：</p><pre id="9ea43101-e10e-476e-ba0f-b45d31b19b04" class="code code-wrap"><code>public static void main(String[] args) {    System.out.println(Person.info);}</code></pre><p id="98890776-a42a-4d63-9d7c-8abb0b4546f3" class="">那么此时同样会使得类初始化，进行加载：</p><figure id="e332daae-6a7f-4ace-9b97-08ef3499998a" class="image"><a href="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png"><img src="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png"/></a></figure><p id="26cfabce-a392-4715-a312-b9e9b69d27df" class="">image-20220921001222465</p><p id="70dacde3-c175-4b5d-89db-d4b3f3688291" class="">可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。</p><p id="91555a7c-b745-4d67-af5e-bedc4458022d" class="">有关类与对象的基本内容，我们就全部讲解完毕了。</p><hr id="7a6cdb42-338d-496a-a03d-876c55025df7"/><h2 id="9986fedc-dcc8-4866-932a-c879d2fbb0f0" class="">包和访问控制</h2><p id="e25192d4-04ac-4edf-a4f2-0063cb8e3374" class="">通过前面的学习，我们知道该如何创建和使用类。</p><h3 id="6854bfe5-cff4-4a03-aad6-87e1c48ce069" class="">包声明和导入</h3><p id="e23f4b01-540e-4998-9420-075299c12524" class="">包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。</p><p id="d452234b-ecf3-4a3d-b0ac-db1417dc67a0" class="">包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，我们的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹，比如<code>com.test</code>：</p><figure id="7d6f9221-00df-4834-a9d4-69ec7de1174f" class="image"><a href="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png"><img src="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png"/></a></figure><p id="c94fa127-4d2d-463d-920f-75d025fc331b" class="">image-20220921120040350</p><p id="9a844dc3-af5a-40d9-8886-33ba0354c747" class="">我们可以将类放入到包中：</p><figure id="da52f3f4-1dd4-4c44-9ca0-9a3ccb1f27ea" class="image"><a href="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png"><img src="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png"/></a></figure><p id="0a8708f3-7994-430d-b749-a57dc7603935" class="">image-20220921115055000</p><p id="03cce0c6-a269-4775-9d77-f65095fe4098" class="">我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：</p><pre id="31a01041-5ecb-4d56-ab63-c5197ae709c7" class="code code-wrap"><code>package com.test;   //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包public class Main {   //将Main类放到com.test这个包中    public static void main(String[] args) {    }}</code></pre><p id="cd2d3d2b-cb01-4f29-b703-31527d27334d" class="">这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p id="0dbb5720-3d2e-4026-a813-7bd5f9418d92" class="">不同的类可以放在不同的包下：</p><figure id="8c92366d-7d55-44d3-9b10-aa0e7840dddf" class="image"><a href="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png"><img src="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png"/></a></figure><p id="aa60c58a-3bfd-4f81-9126-8403e3e57196" class="">image-20220921120241184</p><p id="2280f25a-6f4b-46a2-9562-af3d8d2ea99c" class="">当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：</p><pre id="829e5c8b-a9d0-480c-9e13-d292eb1ce571" class="code code-wrap"><code>package com.test;import com.test.entity.Person;   //使用import关键字导入其他包中的类public class Main {    public static void main(String[] args) {        Person person = new Person();   //只有导入之后才可以使用，否则编译器不知道这个类从哪来的    }}</code></pre><p id="74a4abdc-0eba-4462-8800-e6f6e3f338e1" class="">这里使用了<code>import</code>关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用<code>*</code>表示导入这个包中全部的类：</p><pre id="0677bac4-cbb0-4afc-b4d8-8adc8a8825a7" class="code code-wrap"><code>import com.test.entity.*;</code></pre><p id="5788667d-0c40-47c0-9792-1fb0b4030843" class="">实际上我们之前一直在使用的<code>System</code>类，也是在一个包中的：</p><pre id="9972f97d-98bc-4b20-a9fc-56dc8622e50a" class="code code-wrap"><code>package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;import jdk.internal.util.StaticProperty;/** * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author  unascribed * @since   JDK1.0 */public final class System {      ...}</code></pre><p id="df56f625-ce35-4566-aa03-b671ac82fe15" class="">可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此我们不需要手动指定。</p><p id="c2d9f333-501f-4a18-931a-4ecd534493a1" class="">IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。</p><p id="b4bb0597-4dc2-4bbf-b3de-01844e6a089b" class="">注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><pre id="c1589517-359f-476c-a06a-ed234e2fbced" class="code code-wrap"><code>package com.test.entity;public class String {    //我们在自己的包中也建一个名为String的类}</code></pre><p id="dd71e302-b4bb-4de6-810b-b129ec1d0420" class="">当我们在使用时：</p><figure id="60c64dce-8504-41b8-9462-9fa8466040f0" class="image"><a href="https://www.notion.so/Users/nagocoler/Library/Application%20Support/typora-user-images/image-20220921121404900.png"><img src="https://www.notion.so/Users/nagocoler/Library/Application%20Support/typora-user-images/image-20220921121404900.png"/></a></figure><p id="324ae224-0810-4a9e-a432-5e789719e9c7" class="">image-20220921121404900</p><p id="0b9f3ecf-f593-45a6-a049-f79160f1d4e0" class="">由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：</p><pre id="6905b297-e890-4e6e-92ca-c1b5c80d2c4a" class="code code-wrap"><code>public class Main {    public static void main(java.lang.String[] args) {   //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了                com.test.entity.String string = new com.test.entity.String();    }}</code></pre><p id="91d6e8f9-11d1-4aa6-8d9c-a6f002808876" class="">我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><p id="cf871e2d-f983-4673-bad6-803a10261c05" class="">可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？</p><figure id="38dafa3c-23a6-4e31-bee6-de05e36973d9" class="image"><a href="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png"><img src="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png"/></a></figure><p id="5c5c3059-4379-4260-bf1d-8dfaa0c23b4c" class="">image-20220921122514457</p><p id="e84b1126-c991-4a34-bac3-68c85fe380cc" class="">编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。</p><h3 id="4e9ccde7-bb29-43ce-8c4d-2211ad23b772" class="">访问权限控制</h3><p id="9240a0bb-9c9a-4ee1-9491-d9e88880892f" class="">实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。</p><p id="59661f1f-fdcc-4fcb-8d5f-85f10c447356" class="">所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul id="c2bf72cb-266a-4400-82c4-b785a6dd9a9e" class="bulleted-list"><li style="list-style-type:disc"><code>private</code> - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li></ul><ul id="92b27453-fc04-4b42-ad6a-3c288a7f2302" class="bulleted-list"><li style="list-style-type:disc"><code>什么都不写</code> - 默认，默认情况下，只能被类本身和同包中的其他类访问。</li></ul><ul id="efb3e489-e9d1-4442-b5ad-409058250c58" class="bulleted-list"><li style="list-style-type:disc"><code>protected</code> - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）</li></ul><ul id="bcd4e332-7b18-416a-8745-963fe37112c0" class="bulleted-list"><li style="list-style-type:disc"><code>public</code> - 公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p id="68107b2b-6208-466f-b323-e55168c87771" class="">这四种访问权限，总结如下表：</p><table id="fa4db74f-f17a-4c19-963f-636ffa7ed185" class="simple-table"><tbody><tr id="2da7866e-0142-4f0d-bedd-7d50724739d3"><td id="Worr" class=""></td><td id="L@np" class="">当前类</td><td id="]EFI" class="">同一个包下的类</td><td id="CH[f" class="">不同包下的子类</td><td id="cjli" class="">不同包下的类</td></tr><tr id="0c728ed3-ff37-4c15-b50b-23210a5de89b"><td id="Worr" class="">public</td><td id="L@np" class="">✅</td><td id="]EFI" class="">✅</td><td id="CH[f" class="">✅</td><td id="cjli" class="">✅</td></tr><tr id="2064b7e2-30fb-4018-bdcc-0edf3bc956a4"><td id="Worr" class="">protected</td><td id="L@np" class="">✅</td><td id="]EFI" class="">✅</td><td id="CH[f" class="">✅</td><td id="cjli" class="">❌</td></tr><tr id="3024c522-3c96-48f9-85a8-3b5388fc18c9"><td id="Worr" class="">默认</td><td id="L@np" class="">✅</td><td id="]EFI" class="">✅</td><td id="CH[f" class="">❌</td><td id="cjli" class="">❌</td></tr><tr id="0aa704c5-f5ea-4f24-afa1-200019db4c0b"><td id="Worr" class="">private</td><td id="L@np" class="">✅</td><td id="]EFI" class="">❌</td><td id="CH[f" class="">❌</td><td id="cjli" class="">❌</td></tr></tbody></table><p id="cb424368-914b-46d8-9b0e-9d864cf2f0e1" class="">比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：</p><pre id="433ab334-7e40-44b1-bd02-dab385fbe607" class="code code-wrap"><code>public class Person {    public String name;   //在name变量前添加public关键字，将其可见性提升为公共等级    int age;    String sex;}</code></pre><p id="00929cf6-83d8-493c-b191-ef00899e1c13" class="">这样我们就可以在外部正常使用这个属性了：</p><pre id="a6ca78fd-4ea2-439d-a9ce-59dbc601b6ea" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Person();    System.out.println(person.name);   //正常访问到成员变量}</code></pre><p id="1e2729ab-2299-495c-a2e3-2fa6949a8ed8" class="">实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是<code>public</code>：</p><pre id="898cfed9-8634-41d7-b752-9548562ca30e" class="code code-wrap"><code>package com.test.entity;public class Person {   //class前面有public关键字}</code></pre><p id="c8798a76-8a03-4aef-a66f-51e19da8431a" class="">也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：</p><pre id="b7cab120-ada0-4b4c-aa31-0bd948e10e02" class="code code-wrap"><code>package com.test.entity;class Person {    //去掉public变成默认等级}</code></pre><p id="e008fa4d-449a-4313-901b-b0d0dff7115e" class="">如果是默认等级的话，那么在外部同样是无法访问的：</p><figure id="d2d9b2ad-6f84-4cdd-87f2-e1a045fd7e51" class="image"><a href="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png"><img src="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png"/></a></figure><p id="69ba8383-be00-4794-ae89-a1592d9a3f45" class="">image-20220921142724239</p><p id="4d75a089-9c9b-4286-a66e-4f7b55097c8f" class="">但是注意，我们创建的普通类不能是<code>protected</code>或是<code>private</code>权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是<code>private</code>谁都不能用，那这个类定义出来干嘛呢？</p><p id="0a632a14-8108-4928-903b-d6171b8a8fb4" class="">如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：</p><pre id="96591d93-92d3-461c-a6a7-fc7c2676d7ce" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    public static void test(){        System.out.println(&quot;我是静态方法！&quot;);    }}</code></pre><p id="b80f61c6-23a5-41b4-b8fb-9574fb488f97" class="">我们来尝试一下静态导入：</p><pre id="d5768831-d761-4112-839c-47866d6fdf78" class="code code-wrap"><code>import static com.test.entity.Person.test;    //静态导入test方法public class Main {    public static void main(String[] args) {        test();    //直接使用就可以，就像在这个类定义的方法一样    }}</code></pre><p id="b0c11313-bfee-41f1-b259-c79265a86c20" class="">至此，有关包相关的内容，我们就讲解到这里。</p><hr id="916fde6f-3509-4817-a350-019606925a39"/><h2 id="96fc9dc5-faf6-48a6-9d3e-f77c0cb5e449" class="">封装、继承和多态</h2><p id="6aecfc66-f664-4aaa-8a7a-1eb9d42d4793" class="">封装、继承和多态是面向对象编程的三大特性。</p><blockquote id="c2e2816f-9659-4477-9e88-a2c413f51657" class="">封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。<p id="872a0f6d-7d1e-49b8-a0a9-eaa0a015c4b6" class="">继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p id="785d9f54-1b34-4b66-a854-4dc698961bdc" class="">多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p id="bb358932-6335-4cf1-9528-fc03d7252e9f" class="">正是这三大特性，让我们的Java程序更加生动形象。</p><h3 id="a356030c-0492-460a-bb0d-6eecdb797a97" class="">类的封装</h3><p id="c5fb9602-6b46-4f10-8901-eb7fefb40b26" class="">封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p id="549c2911-c3d1-46de-a742-a40406dd0532" class="">我们可以将之前的类进行改进：</p><pre id="93f46d5f-eeee-4b7f-8028-0bbbcfe9f0fb" class="code code-wrap"><code>public class Person {    private String name;    //现在类的属性只能被自己直接访问    private int age;    private String sex;    public Person(String name, int age, String sex) {   //构造方法也要声明为公共，否则对象都构造不了        this.name = name;        this.age = age;        this.sex = sex;    }    public String getName() {        return name;    //想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改    }    public String getSex() {        return sex;    }    public int getAge() {        return age;    }}</code></pre><p id="5398fef2-9514-4ef1-be3a-0257de6d5c29" class="">我们可以来试一下：</p><pre id="ec8d7cb9-3260-40aa-b720-719b06391d06" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Person(&quot;小明&quot;, 18, &quot;男&quot;);    System.out.println(person.getName());    //只能通过调用getName()方法来获取名字}</code></pre><p id="b3da6b38-d24a-4a88-8956-2cac67c41364" class="">也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含“小”这个字：</p><pre id="982db65a-dd16-471d-96e0-184cf83565bf" class="code code-wrap"><code>public void setName(String name) {    if(name.contains(&quot;小&quot;)) return;    this.name = name;}</code></pre><p id="dd21b06e-20aa-4e17-b0b6-805532ea504d" class="">我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：</p><pre id="fd7b2059-31f6-43c0-a062-52cfbe81d6e8" class="code code-wrap"><code>public class Person {    private String name;    private int age;    private String sex;    private Person(){}   //不允许外部使用new关键字创建对象    public static Person getInstance() {   //而是需要使用我们的独特方法来生成对象并返回        return new Person();    }}</code></pre><p id="5bc7aeea-4fab-453c-9e3f-6fa904e801fc" class="">通过这种方式，我们可以实现单例模式：</p><blockquote id="72162fc7-9222-46f3-bd1b-764893c782b9" class="">public class Test {    private static Test instance;        private Test(){}        public static Test getInstance() {        if(instance == null)             instance = new Test();        return instance;    }}<p id="02278982-a536-49af-bd4e-5639433875ad" class="">单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。</p></blockquote><p id="2a911ca5-6e6d-4f47-9c7a-f5e8ce4dfb74" class="">封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="0b81a2a0-e8ad-4d47-9161-a23aa8822143" class="">类的继承</h3><p id="9bc8df96-1a09-4ad2-a3ba-bfc7e490e966" class="">前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p id="e76acaad-6746-403c-ac5b-c89ef41178b6" class="">在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p id="4a02d918-a100-41c8-b804-61417da7478e" class="">比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：</p><figure id="6ca3c548-6cd1-45e0-97fc-356b6ed7ac3f" class="image"><a href="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png"><img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png"/></a></figure><p id="6e10d461-713d-4c15-9c6f-21c0fc9605dc" class="">image-20220921150139125</p><p id="5c594cda-0563-451d-82be-bfdf6471bedd" class="">实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：</p><pre id="dbf625a2-a513-4731-a1d3-59463b7a0116" class="code code-wrap"><code>public class Person {   //先定义一个父类    String name;    int age;    String sex;}</code></pre><p id="642a3b8a-c8ad-4273-b938-76c7f3948eed" class="">接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用<code>extends</code>关键字即可：</p><pre id="5e5bc84a-ad3b-4c9f-9c1a-450394e35502" class="code code-wrap"><code>public class Worker extends Person{    //工人类}</code></pre><pre id="2284ca48-77a1-4572-b16b-f4280eb86fef" class="code code-wrap"><code>public class Student extends Person{   //学生类}</code></pre><p id="d88e8983-3066-4ef0-9d63-b2fb43d3f10e" class="">类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><pre id="893b27c5-37ba-49e0-81e1-4eb8647c21fd" class="code code-wrap"><code>public final class Person {  //class前面添加final关键字表示这个类已经是最终形态，不能继承}</code></pre><p id="aececc41-3925-4f5f-a989-c7f66fa6a7bf" class="">当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><pre id="9d6498a5-b89f-421a-ac0f-215371153778" class="code code-wrap"><code>public class Student extends Person{    public void study(){        System.out.println(&quot;我的名字是 &quot;+name+&quot;，我在学习！&quot;);   //可以直接访问父类中定义的name属性    }}</code></pre><p id="903c276a-9b3e-44f9-b450-5261b60d7441" class="">同样的，在父类中定义的方法同样会被子类继承：</p><pre id="109c1582-116f-45eb-baef-cec7fcdd9ad6" class="code code-wrap"><code>public class Person {    String name;    int age;    String sex;    public void hello(){        System.out.println(&quot;我叫 &quot;+name+&quot;，今年 &quot;+age+&quot; 岁了!&quot;);    }}</code></pre><p id="641052ab-fdb9-4c16-88f5-ffe4a33f0d2d" class="">子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：</p><pre id="914df1be-5133-4d70-af19-e15226fe2ef8" class="code code-wrap"><code>public static void main(String[] args) {    Student student = new Student();    student.study();    //子类不仅有自己的独特技能    student.hello();    //还继承了父类的全部技能}</code></pre><p id="c818d5e8-a892-4ef9-a0b5-e74d4a45c4b5" class="">是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p id="2431842c-17ff-4712-bbcc-bf6f84089915" class="">如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><pre id="d2ebf705-7728-46a7-a8fd-da3aee81f748" class="code code-wrap"><code>public class Person {    protected String name;   //因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问    protected int age;    protected String sex;    protected String profession;    //构造方法也改成protected，只能子类用    protected Person(String name, int age, String sex, String profession) {        this.name = name;        this.age = age;        this.sex = sex;        this.profession = profession;    }    public void hello(){        System.out.println(&quot;[&quot;+profession+&quot;] 我叫 &quot;+name+&quot;，今年 &quot;+age+&quot; 岁了!&quot;);    }}</code></pre><p id="0dac994e-f6dc-44fd-a2e5-c00b8a1ecf05" class="">可以看到，此时两个子类都报错了：</p><figure id="51d3e620-3741-46ad-a2b1-ba4bbe2fc740" class="image"><a href="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png"><img src="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png"/></a></figure><p id="db76c72e-3fb3-428b-9b91-5b45c54aae52" class="">image-20220921153512798</p><p id="f2c22aab-557d-4748-8a9d-07a47c3977ce" class="">因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：</p><p id="039369ba-1a30-41fe-b01d-76bb336d11b5" class="">既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><pre id="234813e5-fd0f-4f36-bb64-07da05572c8a" class="code code-wrap"><code>public class Student extends Person{    public Student(String name, int age, String sex) {    //因为学生职业已经确定，所以说学生直接填写就可以了        super(name, age, sex, &quot;学生&quot;);   //使用super代表父类，父类的构造方法就是super()    }    public void study(){        System.out.println(&quot;我的名字是 &quot;+name+&quot;，我在学习！&quot;);    }}</code></pre><pre id="35ee9670-5a65-44c8-9b09-7eeefce404f9" class="code code-wrap"><code>public class Worker extends Person{    public Worker(String name, int age, String sex) {        super(name, age, sex, &quot;工人&quot;);    //父类构造调用必须在最前面        System.out.println(&quot;工人构造成功！&quot;);    //注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行    }}</code></pre><p id="da55d241-1e92-40b7-badc-73907d3f7957" class="">我们在使用子类时，可以将其当做父类来使用：</p><pre id="53c455ae-5dc1-4a82-aa65-d04dd81e96cd" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    //这里使用父类类型的变量，去引用一个子类对象（向上转型）    person.hello();    //父类对象的引用相当于当做父类来使用，只能访问父类对象的内容}</code></pre><p id="67805559-e489-4e8d-8165-232983122d28" class="">虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p id="a21170db-0a50-4da4-b9c7-ea222816f9d5" class="">我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><pre id="34af46d0-dc15-44a9-b86c-e65aa3127c71" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    Student student = (Student) person;   //使用强制类型转换（向下转型）    student.study();}</code></pre><p id="129970ed-b0b7-426e-a1d4-aa957d39dc65" class="">但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><pre id="263f86db-ecab-4834-919e-ea050360c803" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Worker(&quot;小明&quot;, 18, &quot;男&quot;);   //实际创建的是Work类型的对象    Student student = (Student) person;    student.study();}</code></pre><figure id="9e2794dc-d2c2-4328-a36b-2b9f2db15ed5" class="image"><a href="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png"><img src="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png"/></a></figure><p id="d678b68f-9946-4f81-92e5-2dc069120414" class="">image-20220921160309835</p><p id="fcb21ad8-2b3e-4a79-a5e4-4675e375d3c8" class="">此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p id="e32958e2-96f4-4dbe-99b2-8ae2814d9e42" class="">那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><pre id="150a0d2e-ad95-4dea-b54c-131a46cecb22" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    if(person instanceof Student) {   //我们可以使用instanceof关键字来对类型进行判断        System.out.println(&quot;对象是 Student 类型的&quot;);    }    if(person instanceof Person) {        System.out.println(&quot;对象是 Person 类型的&quot;);    }}</code></pre><p id="2fc89da8-ba38-4804-850a-a2814e865d36" class="">如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p id="c07af5fd-f334-4046-ae2a-456a22404560" class="">最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><pre id="f4dba5d6-4c31-47f1-be33-4676c958749c" class="code code-wrap"><code>public class Worker extends Person{    protected String name;   //子类中同样可以定义name属性    public Worker(String name, int age, String sex) {        super(name, age, sex, &quot;工人&quot;);    }}</code></pre><p id="d0d6aa1e-0245-4946-8258-0f0ca885ac30" class="">此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：</p><pre id="86be2292-c410-4868-9c18-239bb2114c24" class="code code-wrap"><code>public void work(){    System.out.println(&quot;我是 &quot;+name+&quot;，我在工作！&quot;);   //这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性}</code></pre><p id="c416160c-5eb4-4db8-846d-f884a1713f89" class="">所以说，我们在使用时，实际上这里得到的结果为<code>null</code>：</p><figure id="41771bde-bd2f-42cb-9d8d-c915a3687572" class="image"><a href="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png"><img src="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png"/></a></figure><p id="c8c0f429-3441-46ff-a9cc-067bdd1a3fc9" class="">image-20220921160742714</p><p id="504c85cd-64e0-4784-ab4b-c7c1aa319594" class="">那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用<code>super</code>关键字来表示父类：</p><pre id="afceeec7-9697-4dc7-98fa-16fb33254a50" class="code code-wrap"><code>public void work(){    System.out.println(&quot;我是 &quot;+super.name+&quot;，我在工作！&quot;);   //这里使用super.name来表示需要的是父类的name变量}</code></pre><p id="87126e25-4344-4107-83dd-b56b887a2981" class="">这样得到的结果就不一样了：</p><figure id="c320a6e9-4f77-45a6-951f-fb0aadaaeb0f" class="image"><a href="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png"><img src="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png"/></a></figure><p id="eea212e2-cef4-4076-a667-5f68e017ce04" class="">image-20220921160851193</p><p id="c17c660d-32aa-4a0c-9fc5-c8d9bd8fd8e4" class="">但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="88d1cb31-3630-4926-879c-0d40f178eb7e" class="">顶层Object类</h3><p id="497d52da-d186-4129-b4e7-1f58f41f698a" class="">实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><figure id="12c45883-441c-4c10-946d-1345266fe3a5" class="image"><a href="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png"><img src="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png"/></a></figure><p id="2a5ab570-fc93-49ad-b687-acdb3b5d6ecd" class="">image-20220921214642969</p><p id="3945568d-1da5-4c61-a205-441343e4605f" class="">我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><pre id="7fe2c99d-f2b6-410a-8011-33dce4c73af0" class="code code-wrap"><code>public class Person extends Object{//除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略}</code></pre><p id="f33c4fb2-96e8-42c2-b3a1-36cd0bd7438a" class="">所以说我们的继承结构差不多就是：</p><figure id="8d87399a-3708-4cf5-9918-051da3e30337" class="image"><a href="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png"><img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png"/></a></figure><p id="f078d3f5-eedc-4faf-8b9e-0e34f85d6c11" class="">image-20220921214944267</p><p id="8cec3d9c-9c47-4b83-88e0-b9919ae728a0" class="">既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：</p><pre id="ca615453-fea5-442f-a6a2-6ec72e3c2c3a" class="code code-wrap"><code>public class Object {    private static native void registerNatives();   //标记为native的方法是本地方法，底层是由C++实现的    static {        registerNatives();   //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍    }    //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到    public final native Class&lt;?&gt; getClass();    //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址    public native int hashCode();    //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象    public boolean equals(Object obj) {        return (this == obj);    }    //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性    protected native Object clone() throws CloneNotSupportedException;    //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值    public String toString() {        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());    }    //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到    public final native void notify();    //唤醒所有等待当前对象锁的线程，同上    public final native void notifyAll();    //使得持有当前对象锁的线程进入等待状态，同上    public final native void wait(long timeout) throws InterruptedException;    //同上    public final void wait(long timeout, int nanos) throws InterruptedException {        ...    }    //同上    public final void wait() throws InterruptedException {        ...    }    //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到    protected void finalize() throws Throwable { }}</code></pre><p id="c188e09f-9bb1-407a-8aae-2256fc7a6803" class="">这里我们可以尝试调用一下Object为我们提供的<code>toString()</code>方法：</p><pre id="4013c973-bad4-46fb-8fb5-382e55ec6418" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    String str = person.toString();    System.out.println(str);}</code></pre><p id="c25623bf-69d2-4f6a-b8c1-6bee287121ea" class="">这里就是按照上面说的格式进行打印：</p><figure id="45160328-8eff-4712-93e8-2b6d06f6c687" class="image"><a href="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png"><img src="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png"/></a></figure><p id="7d941cac-dd1c-45d6-9dd0-38238a042fab" class="">image-20220921221053801</p><p id="061dd5e9-1684-4047-a4ed-c7f74aafea12" class="">当然，我们直接可以给<code>println</code>传入一个Object类型的对象：</p><pre id="98d9375b-0329-4bce-8c40-dd82ece392a7" class="code code-wrap"><code>public void println(Object x) {    String s = String.valueOf(x);   //这里同样会调用对象的toString方法，所以说跟上面效果是一样的    synchronized (this) {        print(s);        newLine();    }}</code></pre><p id="2789dfcc-0c21-4637-bd7e-2d8dc30ba571" class="">有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p id="b1b2f9bf-cb14-4023-a59a-5503bee15b7e" class="">我们也可以试试看默认提供的<code>equals</code>方法：</p><pre id="5e7492bc-50a0-457a-b4a3-9ff2a900bcca" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    Person p2 = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    System.out.println(p1.equals(p2));}</code></pre><p id="0a831c09-85c5-4eb6-8fe5-037b320944c9" class="">因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="6082e2c2-1944-4fdf-a90d-9b03ad3b4445" class="">方法的重写</h3><p id="23949cb2-6213-4739-8655-5bb9e3457ec8" class="">注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的<code>equals</code>方法，那么我们就可以将其重写了：</p><pre id="d31162e6-ed0e-494e-ab66-289c2465b5cc" class="code code-wrap"><code>public class Person{    ...    @Override   //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略    public boolean equals(Object obj) {   //重写方法要求与父类的定义完全一致        if(obj == null) return false;   //如果传入的对象为null，那肯定不相等        if(obj instanceof Person) {     //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么            Person person = (Person) obj;   //先转换为当前类型，接着我们对三个属性挨个进行比较            return this.name.equals(person.name) &amp;&amp;    //字符串内容的比较，不能使用==，必须使用equals方法                    this.age == person.age &amp;&amp;       //基本类型的比较跟之前一样，直接==                    this.sex.equals(person.sex);        }        return false;    }}</code></pre><p id="202a7c2a-b1b3-4f47-bc05-e8179caaae3e" class="">在重写Object提供的<code>equals</code>方法之后，就会按照我们的方式进行判断了：</p><pre id="adeacc18-c827-4dfb-8402-e41348be5948" class="code code-wrap"><code>public static void main(String[] args) {    Person p1 = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    Person p2 = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    System.out.println(p1.equals(p2));   //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象}</code></pre><p id="b25a1a9a-3157-4915-9531-b7aecae496b3" class="">有时候为了方便查看对象的各个属性，我们可以将Object类提供的<code>toString</code>方法重写了：</p><pre id="cf6e7c3b-8818-4ef0-b100-1db73439881e" class="code code-wrap"><code>@Overridepublic String toString() {    //使用IDEA可以快速生成    return &quot;Person{&quot; +            &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +            &quot;, age=&quot; + age +            &quot;, sex=&#x27;&quot; + sex + &#x27;\&#x27;&#x27; +            &quot;, profession=&#x27;&quot; + profession + &#x27;\&#x27;&#x27; +            &#x27;}&#x27;;}</code></pre><p id="564b9a12-30d5-4fec-ae92-4bc5292ea54a" class="">这样，我们直接打印对象时，就会打印出对象的各个属性值了：</p><pre id="de71a083-695a-4ec1-8469-1e319550173a" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    System.out.println(person);}</code></pre><figure id="c3f40aba-2d40-437e-b46d-7e9df4f38ee6" class="image"><a href="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png"><img src="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png"/></a></figure><p id="0a3dd706-7eca-40f0-a270-36a29f2501c6" class="">image-20220921223249343</p><p id="5c01e558-dcb6-40ea-881f-5a23e15374fa" class="">注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p id="d8cac433-af9d-468b-afaf-4faf39fa6ac7" class="">基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><pre id="ac3236c4-e4d6-4cca-b269-8636dd49e41b" class="code code-wrap"><code>public class Person {    ...    public void exam(){        System.out.println(&quot;我是考试方法&quot;);    }    ...}</code></pre><pre id="d1a8ef16-b343-42cf-91da-cc74a6c5d850" class="code code-wrap"><code>public class Student extends Person{    ...    @Override    public void exam() {        System.out.println(&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;);    }}</code></pre><pre id="65da9e1a-e847-46df-9428-b505b136d0be" class="code code-wrap"><code>public class Worker extends Person{    ...    @Override    public void exam() {        System.out.println(&quot;我是工人，做题我并不擅长，只能得到 D&quot;);    }}</code></pre><p id="098add22-10c1-41ec-a957-36130928d197" class="">这样，不同的子类，对于同一个方法会产生不同的结果：</p><pre id="4b44fd4d-b502-4d8c-843c-6e5d3802130d" class="code code-wrap"><code>public static void main(String[] args) {    Person person = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    person.exam();    person = new Worker(&quot;小强&quot;, 18, &quot;男&quot;);    person.exam();}</code></pre><figure id="4c8fa8b8-65bd-4827-beb1-2dd035034822" class="image"><a href="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png"><img src="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png"/></a></figure><p id="1bb2f280-81dd-46a8-a00a-ee357f6c67d3" class="">image-20220921224525855</p><p id="48d243ce-f2aa-4d30-a951-c5997fe50e82" class="">这其实就是面向对象编程中多态特性的一种体现。</p><p id="4ce8b2a3-9752-44a8-b249-6ba3edf11642" class="">注意，我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><pre id="639953b8-58c4-4ee9-b9f7-b6f275e84803" class="code code-wrap"><code>public final void exam(){    System.out.println(&quot;我是考试方法&quot;);}</code></pre><figure id="9ee00f5b-a2b3-475c-960b-723588af3526" class="image"><a href="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png"><img src="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png"/></a></figure><p id="19903414-53fb-4375-92fc-cf80cf9a5498" class="">image-20220921224907373</p><p id="9db58c8d-3638-4a84-8c50-0a5ae36a76ab" class="">或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><figure id="d2b16e7c-bef7-462e-aa62-dfe450f70067" class="image"><a href="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png"><img src="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png"/></a></figure><p id="28d817e6-f139-44a7-9af5-f6778d83f11b" class="">image-20220921225651487</p><p id="29e5ba68-4a56-4ff1-8594-11fc4b151a7d" class="">虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p id="d5cc1d7d-e418-491d-b008-aa1fb379f422" class="">还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><pre id="8a8163ae-250e-4d0f-a372-65d48c50ef5e" class="code code-wrap"><code>@Overridepublic void exam() {    super.exam();   //调用父类的实现    System.out.println(&quot;我是工人，做题我并不擅长，只能得到 D&quot;);}</code></pre><p id="312a0649-2094-4f85-bbf6-61dd6b2081cf" class="">然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><pre id="606c46a7-8cd6-42fa-b226-7009fc8af1c5" class="code code-wrap"><code>public void exam(){    System.out.println(&quot;我是考试方法&quot;);}</code></pre><figure id="4d9c64f9-e4f4-4e82-b667-0f9fda9b51a9" class="image"><a href="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png"><img src="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png"/></a></figure><p id="cea43d6a-1fce-4467-aca1-420514e947d1" class="">image-20220921225234226</p><p id="d71ba6d7-36bf-4058-b6a1-0c3381498973" class="">因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：</p><pre id="faff55a3-0cc1-4b09-b6db-4b7e4e6c5ba3" class="code code-wrap"><code>protected void exam(){    System.out.println(&quot;我是考试方法&quot;);}</code></pre><pre id="98d18569-3ff1-421f-8f61-cdeb24425942" class="code code-wrap"><code>@Overridepublic void exam() {   //将可见性提升为public    System.out.println(&quot;我是工人，做题我并不擅长，只能得到 D&quot;);}</code></pre><figure id="989c38f3-e624-4fed-83f4-baa86c95ee6f" class="image"><a href="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png"><img src="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png"/></a></figure><p id="053eacde-2dab-4e8f-bed1-35d0cc5288f2" class="">image-20220921225840122</p><p id="fbe4270c-ee95-4ad4-ae18-7106382b1165" class="">可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。</p><h3 id="ed144111-8520-4c99-906a-cad84b7ee4a8" class="">抽象类</h3><p id="52fbae07-7efa-412f-bbb0-fd3d48930ee8" class="">在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：</p><pre id="53ff860e-0e2f-493b-aa28-926f9ef159de" class="code code-wrap"><code>protected void exam(){    System.out.println(&quot;我是考试方法&quot;);}</code></pre><p id="6d5e7e6d-d6d2-401c-8740-09279c485b99" class="">这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p id="7b529464-669f-492d-8e74-800e5f32a974" class="">要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：</p><pre id="04a911be-cf4f-437b-8d0e-b0c22a65eb78" class="code code-wrap"><code>public abstract class Person {   //通过添加abstract关键字，表示这个类是一个抽象类    protected String name;   //大体内容其实普通类差不多    protected int age;    protected String sex;    protected String profession;    protected Person(String name, int age, String sex, String profession) {        this.name = name;        this.age = age;        this.sex = sex;        this.profession = profession;    }    public abstract void exam();   //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体}</code></pre><p id="753c46d5-bd21-4252-b04e-564036b88f80" class="">而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><pre id="c2e76542-8ba8-4d23-a031-444e3caae74a" class="code code-wrap"><code>public class Worker extends Person{    public Worker(String name, int age, String sex) {        super(name, age, sex, &quot;工人&quot;);    }    @Override    public void exam() {   //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译        System.out.println(&quot;我是工人，做题我并不擅长，只能得到 D&quot;);    }}</code></pre><p id="da1cf465-af4a-41e4-9157-d7aa34905069" class="">抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><figure id="4c596127-53a8-43c2-90d7-459cd66657b0" class="image"><a href="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png"><img src="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png"/></a></figure><p id="57f92ed0-13b0-4c2d-a752-cd4af7f6262f" class="">image-20220921231744420</p><p id="38111384-23e3-4dfa-b169-904e13ad53a5" class="">要使用抽象类，我们只能去创建它的子类对象。</p><p id="49250ff5-3d54-4b70-8c24-071c9ef15e06" class="">抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><pre id="c252d154-2f65-42d3-aedc-da0dfcc2677c" class="code code-wrap"><code>public abstract class Student extends Person{   //如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法    public Student(String name, int age, String sex) {        super(name, age, sex, &quot;学生&quot;);    }    @Override   //抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现    public void exam() {        System.out.println(&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;);    }}</code></pre><p id="f6ecf5c3-dfaf-481f-8585-76029a1bb2bd" class="">注意，抽象方法的访问权限不能为<code>private</code>：</p><figure id="fd891f81-7e34-4b60-83a7-5b85670f8468" class="image"><a href="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png"><img src="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png"/></a></figure><p id="6217f983-a123-4088-b622-7965c333b08e" class="">image-20220921232435056</p><p id="406731d5-8729-4c6d-9314-20d90a6dc34a" class="">因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。</p><h3 id="5a99a1a3-43c2-4e25-b765-cdb41fa63954" class="">接口</h3><p id="51062613-4309-444e-9546-2b4b194d66ba" class="">接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p id="96f2196f-521e-4c01-9d82-e1d98c66a85a" class="">咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p id="f3bbeb2f-7b64-4e96-bb94-7864b9014d6b" class="">比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><pre id="8d9f1b2d-7334-4a00-b141-2a0315538a43" class="code code-wrap"><code>public interface Study {    //使用interface表示这是一个接口    void study();    //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略}</code></pre><p id="4910eb14-b84b-421d-ae28-c18d41a5d527" class="">我们可以让类实现这个接口：</p><pre id="e8e31580-9e7d-4e56-ba2d-803eb4844fbd" class="code code-wrap"><code>public class Student extends Person implements Study {   //使用implements关键字来实现接口    public Student(String name, int age, String sex) {        super(name, age, sex, &quot;学生&quot;);    }    @Override    public void study() {    //实现接口时，同样需要将接口中所有的抽象方法全部实现        System.out.println(&quot;我会学习！&quot;);    }}</code></pre><pre id="fb27f4ef-6ecf-4b30-b7c6-812cc41cc02c" class="code code-wrap"><code>public class Teacher extends Person implements Study {    protected Teacher(String name, int age, String sex) {        super(name, age, sex, &quot;教师&quot;);    }    @Override    public void study() {        System.out.println(&quot;我会加倍学习！&quot;);    }}</code></pre><p id="c3d3bf37-b544-4f22-a245-3ad1d62182f9" class="">接口不同于继承，接口可以同时实现多个：</p><pre id="287d9578-e669-4c0c-b122-3242c1b53f09" class="code code-wrap"><code>public class Student extends Person implements Study, A, B, C {  //多个接口的实现使用逗号隔开}</code></pre><p id="a20cbd89-1ac8-449f-b4e2-3cdcf365a7e6" class="">所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p id="68e9c8cc-2e97-49f8-8583-643ef318a3ed" class="">接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：</p><figure id="e302603d-dd81-4a9c-a8ab-483d82933850" class="image"><a href="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png"><img src="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png"/></a></figure><p id="02fe9553-4568-4e1a-9e1b-55e345c829dc" class="">image-20220921234735828</p><p id="18155c30-5659-4bdc-8d23-171de5c30fa6" class="">当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p id="f8ff2922-ce50-4cb3-897f-fdf6023da4fb" class="">接口同样支持向下转型：</p><pre id="378686c1-7c3d-4e16-94f0-6e1bbf28aeb2" class="code code-wrap"><code>public static void main(String[] args) {    Study study = new Teacher(&quot;小王&quot;, 27, &quot;男&quot;);    if(study instanceof Teacher) {   //直接判断引用的对象是不是Teacher类型        Teacher teacher = (Teacher) study;   //强制类型转换        teacher.study();    }}</code></pre><p id="f33541fb-cd50-4a7d-a485-f5501c3c1aa7" class="">这里的使用其实跟之前的父类是差不多的。</p><p id="0c7b261c-6f95-4e5b-9d7c-18519d82d4eb" class="">从Java8开始，接口中可以存在方法的默认实现：</p><pre id="0f6c891d-1011-469b-801a-6e4c05eb236b" class="code code-wrap"><code>public interface Study {    void study();    default void test() {   //使用default关键字为接口中的方法添加默认实现        System.out.println(&quot;我是默认实现&quot;);    }}</code></pre><p id="01505c56-f03c-45ae-b3f8-200ade73d9ce" class="">如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p id="b48a3fc3-91a6-404a-96c5-3659b601015e" class="">接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：</p><pre id="46eca82a-262d-4598-b3b2-5a047146cc2e" class="code code-wrap"><code>public interface Study {    public static final int a = 10;   //接口中定义的静态变量只能是public static final的    public static void test(){    //接口中定义的静态方法也只能是public的        System.out.println(&quot;我是静态方法&quot;);    }    void study();}</code></pre><p id="8b902d1c-da3d-4aad-bf0b-c02ae44e7fbe" class="">跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：</p><pre id="fc3aa4d5-0f4b-4a39-88fe-1e6f5e5a748d" class="code code-wrap"><code>public static void main(String[] args) {    System.out.println(Study.a);    Study.test();}</code></pre><p id="11773e80-785a-4b8d-9a88-f4741245cab6" class="">接口是可以继承自其他接口的：</p><pre id="e2c078b6-3305-4ec1-84b5-57d98e6bb531" class="code code-wrap"><code>public interface A exetnds B {}</code></pre><p id="6e1e1fc9-a77a-43d5-b43c-13a4b2cc31a7" class="">并且接口没有继承数量限制，接口支持多继承：</p><pre id="02fde293-e736-46bc-b69a-244c71c22460" class="code code-wrap"><code>public interface A exetnds B, C, D {}</code></pre><p id="d7485a67-7eaa-4a3c-b83b-426e223443fb" class="">接口的继承相当于是对接口功能的融合罢了。</p><p id="0ed9ece8-40d0-41dc-a415-77505da4ae75" class="">最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：</p><pre id="6c479be8-5a15-4450-9aa1-bb96897fec34" class="code code-wrap"><code>package java.lang;public interface Cloneable {    //这个接口中什么都没定义}</code></pre><p id="5f48e9af-84b5-4b0b-8ccc-89879f502722" class="">实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：</p><pre id="6cf93ea7-6b42-46c7-98e4-b8c1b4f5fa66" class="code code-wrap"><code>public class Student extends Person implements Study, Cloneable {   //首先实现Cloneable接口，表示这个类具有克隆的功能    public Student(String name, int age, String sex) {        super(name, age, sex, &quot;学生&quot;);    }    @Override    public Object clone() throws CloneNotSupportedException {   //提升clone方法的访问权限        return super.clone();   //因为底层是C++实现，我们直接调用父类的实现就可以了    }    @Override    public void study() {        System.out.println(&quot;我会学习！&quot;);    }}</code></pre><p id="a3802aaa-3336-446f-a522-3701fd0c7736" class="">接着我们来尝试一下，看看是不是会得到一个一模一样的对象：</p><pre id="5f4e52ef-489c-45a0-8a77-1a6d4761da40" class="code code-wrap"><code>public static void main(String[] args) throws CloneNotSupportedException {  //这里向上抛出一下异常，还没学异常，所以说照着写就行了    Student student = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    Student clone = (Student) student.clone();   //调用clone方法，得到一个克隆的对象    System.out.println(student);    System.out.println(clone);    System.out.println(student == clone);}</code></pre><p id="5722255f-8f1b-4a54-ba44-3774936899b3" class="">可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><figure id="bac7c148-16cb-4765-9f05-0810fbab9cc2" class="image"><a href="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png"><img src="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png"/></a></figure><p id="8d118af1-a07f-42df-bd0b-7602f361a9c2" class="">image-20220922110044636</p><p id="d2ef1254-9b5a-43d8-bcea-98ce6e7fd69b" class="">通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。</p><p id="20fc22ce-ab4f-4627-b520-398f6ddc01c5" class=""><strong>注意：</strong>以下内容为选学内容，在设计模式篇视频教程中有详细介绍。</p><blockquote id="0dc44742-dd5b-4461-b110-36ad05fb5590" class="">克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。<ul id="198bb460-9f02-46e1-be5d-1718b6229cab" class="bulleted-list"><li style="list-style-type:disc"><strong>浅拷贝：</strong>对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</li></ul><ul id="049b110a-4034-48a6-9335-cd3ccc122a34" class="bulleted-list"><li style="list-style-type:disc"><strong>深拷贝：</strong>无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p id="bbe33cab-b165-4577-9b41-a19a88dee37f" class="">那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><pre id="ba2f0c55-eb8e-4cb2-9ecf-ee4321f75786" class="code code-wrap"><code>public static void main(String[] args) throws CloneNotSupportedException {    Student student = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    Student clone = (Student) student.clone();    System.out.println(student.name == clone.name);}</code></pre><figure id="a849084e-2593-42cc-bdbc-f3e07978b15a" class="image"><a href="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png"><img src="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png"/></a></figure><p id="5c449c71-f891-4df9-abe7-dc761137ad13" class="">image-20220922110750697</p><p id="f5372702-ab43-40ce-a587-ae96dfe8eac7" class="">可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><hr id="a5c6a3ea-b45d-4336-a2dd-1a90352a4028"/><h2 id="014e6562-76c4-495b-92b8-f090bdacc12b" class="">枚举类</h2><p id="47314116-9e56-4fc1-92b6-c3c8f4ab7d36" class="">假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><pre id="971a535c-6968-420d-b8d3-b90f8456899f" class="code code-wrap"><code>public class Student extends Person implements Study {    private String status;   //状态，可以是跑步、学习、睡觉这三个之中的其中一种    public String getStatus() {        return status;    }    public void setStatus(String status) {        this.status = status;    }}</code></pre><p id="f12b6010-3b05-4268-8a6b-f4fb787f1b9f" class="">但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：</p><pre id="94956b5c-d8fb-48e7-a8ab-010441053510" class="code code-wrap"><code>public enum Status {   //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样    RUNNING, STUDY, SLEEP;    //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上}</code></pre><p id="9213109b-6ea1-45d6-8023-ad3402fb6d34" class="">使用枚举类也非常方便，就像使用普通类型那样：</p><pre id="e0612236-d344-488c-8b51-bd20fc238e33" class="code code-wrap"><code>private Status status;   //类型变成刚刚定义的枚举类public Status getStatus() {    return status;}public void setStatus(Status status) {    this.status = status;}</code></pre><p id="f0832947-3264-4cfb-a2b1-52e27cad3a49" class="">这样，别人在使用时，就能很清楚地知道我们支持哪些了：</p><figure id="e7111c5d-8257-4d54-b2c7-e298bf2994f0" class="image"><a href="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png"><img src="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png"/></a></figure><p id="72936224-1e46-48d4-9e1e-4adddd06f1eb" class="">image-20220922111426974</p><p id="c1984b59-2c69-4602-942b-939b95f8b68c" class="">枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><pre id="91a0a30a-066c-4b47-89ac-9838a1861c61" class="code code-wrap"><code>//这里使用javap命令对class文件进行反编译得到 Compiled from &quot;Status.java&quot;public final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; {  public static final com.test.Status RUNNING;  public static final com.test.Status STUDY;  public static final com.test.Status SLEEP;  public static com.test.Status[] values();  public static com.test.Status valueOf(java.lang.String);  static {};}</code></pre><p id="1048430d-5acf-4f95-9e5e-e69e6770d87a" class="">既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：</p><pre id="f58f7572-ccf3-43f7-8c38-f399414edd17" class="code code-wrap"><code>public enum Status {    RUNNING(&quot;睡觉&quot;), STUDY(&quot;学习&quot;), SLEEP(&quot;睡觉&quot;);   //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）    private final String name;    //枚举的成员变量    Status(String name){    //覆盖原有构造方法（默认private，只能内部使用！）        this.name = name;    }    public String getName() {   //获取封装的成员变量        return name;    }}</code></pre><p id="b2f4177e-1de5-4fca-ad4d-5920719ef565" class="">这样，枚举就可以按照我们想要的中文名称打印了：</p><pre id="996fe018-6d37-412a-a629-e158164e6f45" class="code code-wrap"><code>public static void main(String[] args) {    Student student = new Student(&quot;小明&quot;, 18, &quot;男&quot;);    student.setStatus(Status.RUNNING);    System.out.println(student.getStatus().getName());}</code></pre><p id="c18afcf7-6dd2-4be4-bc41-a9299bc71ed2" class="">枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。</p><p id="f03ca501-3bc6-41fa-a556-d321a7bc6d52" class="">至此，面向对象基础内容就全部讲解完成了，下一章我们还将继续讲解面向对象的其他内容。</p></div></article></body></html>